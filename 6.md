# 6章

##  ` ls -l /dev/`

このコマンドは、LinuxやUNIXのシステムでデバイスファイルが格納されている /dev/ ディレクトリの内容を詳細に表示するためのものです。

具体的にコマンドの各部分について説明します：

- ls: "list" の略で、ディレクトリの内容を表示する基本的なコマンドです。

- -l: このオプションは "long format" を意味し、ディレクトリの内容を詳細に表示します。具体的には、以下の情報が表示されます：

- ファイルのパーミッション
- ハードリンクの数
- ファイルの所有者
- ファイルのグループ
- ファイルのサイズ
- 最後に変更された日時
- ファイル名
- /dev/: /dev/ は、LinuxやUNIXシステムにおいてデバイスファイルを格納するための特別なディレクトリです。このディレクトリには、ハードウェアデバイスを表す特別なファイルや、システム上で利用可能な仮想デバイス（例：/dev/null、/dev/random）を表すファイルが含まれています。

このコマンドを実行すると、/dev/ ディレクトリ内のすべてのデバイスファイルの詳細な情報が表示されます。この情報から、特定のデバイスファイルのパーミッションや所有者、サイズなどの属性を確認することができます。


## `ps ax | grep bash`

ps ax:

ps: プロセスのステータスを表示するコマンドです。
a: すべてのユーザーのプロセスを表示します。
x: ターミナルに関連しないプロセスも表示します。
このコマンドは、システム上で実行中のすべてのプロセスのリストを表示します。

|: パイプ（pipe）と呼ばれるもので、一つのコマンドの出力を別のコマンドの入力として使用するためのものです。

grep bash:

grep: 文字列の検索を行うコマンドです。
bash: 検索したい文字列。
このコマンドは、ps ax の出力から bash という文字列を含む行を検索して表示します。


## `sudo su`

現在のユーザーに root 権限で新しいシェルセッションを開始することを試みます。


詳しく説明すると：

- sudo: SuperUser DO の略で、指定したコマンドをスーパーユーザー権限（通常は root ユーザー）で実行するためのコマンドです。

- su: Switch User の略で、指定されたユーザーに切り替えるためのコマンドです。
      ユーザー名が指定されない場合、デフォルトで root ユーザーに切り替えます。

組み合わせた sudo su は、現在のユーザーに root ユーザーとして新しいシェルセッションを開始する権限を与えるために使用されます。
このコマンドは、システム管理の作業を行う際に root 権限が必要な場合や、
システムの設定を変更するために一時的に root 権限を取得する場合などに使用されます。

注意：root 権限を持つユーザーは、システムに対して全ての操作が可能となるため、このコマンドを使用する際は注意が必要です。
誤った操作がシステムの不具合やデータの喪失を引き起こす可能性があります。



## 新しいシェルセッションとは？
新たなインタラクティブなコマンドラインインターフェイス（CLI）のインスタンスや環境を指します。
シェルは、ユーザーがキーボード入力を用いてコマンドを入力し、その結果を表示するプログラムです。
シェルセッションとは、そのシェルが起動され、ユーザーとの対話が可能な状態を指します。

- 独立した環境: 新しいシェルセッションは、それ自体が独立した環境を持ちます。
              これにより、異なるセッションで異なるタスクや実験を行うことが容易になります。
              例えば、一つのセッションで特定の環境変数を設定して作業を行い、別のセッションではその変数を変更せずに異なる作業を行うことができます。

- 権限の変更: sudo su のようなコマンドを使用して新しいシェルセッションを開始すると、
            そのセッションは異なるユーザー権限で動作します。このため、特定の作業を行うための一時的な権限昇格やユーザーの切り替えが可能です。

- 作業の区切り: 新しいセッションを開始することで、前の作業環境から完全に切り離された状態で作業を開始することができます。
              これは、新しいプロジェクトの開始、トラブルシューティング、実験的なタスクなどの際に有用です。

新しいシェルセッションは、新しいターミナルウィンドウを開いたり、SSH接続を新しく確立したりすることでも開始されます。


mitsu30@ubuntu:/$ sudo su
[sudo] password for mitsu30: 
root@ubuntu:/# 


## $と#の違いはなんですか？
$ と # は、多くのUnix系OSやLinuxのシェルプロンプトで見られる記号で、現在のユーザーの権限レベルを示す目安として使用されます。

$:
通常のユーザー権限でのシェルプロンプトを示します。
つまり、管理者権限（root）ではない一般ユーザーとしてシェルにログインしている状態を示します。
この権限では、システムの全体的な設定変更や、他のユーザーのファイルへのアクセスなどは制限されています。

#:
rootユーザー、またはスーパーユーザー権限でのシェルプロンプトを示します。
この権限レベルでの操作は注意が必要です。なぜなら、システムの重要な設定変更や、任意のファイルへのアクセスが可能であり、
間違った操作がシステム全体に影響を及ぼす可能性があるからです。
この違いを知っておくことは、特にコマンドを実行する前に、現在の権限レベルを確認するために役立ちます。
不要にroot権限を持つセッションで作業を行うのは避けるべきで、必要な操作のみroot権限で行い、
それ以外の通常の作業は一般ユーザー権限で行うのが良いとされています。


## `echo hello`

シェルに hello という文字列を出力する命令です。

具体的には、echo は指定された文字列や変数の内容を標準出力（通常はターミナルやコンソール）に表示するコマンドです。
この場合、hello という文字列が指定されているので、その文字列がターミナルに表示されます。


## 
`mitsu30@ubuntu:/$ sudo su`
`root@ubuntu:/# echo hello >/dev/pts/0`
`hello`

sudo su: このコマンドは、スーパーユーザ（rootユーザ）として新しいシェルを開始します。この結果、プロンプトが root@ubuntu:/# のように変わり、以後のコマンドはroot権限で実行されます。

echo hello: このコマンドは、文字列 hello を標準出力に表示する命令です。

>/dev/pts/0: これはリダイレクトの記号で、echo hello の出力を標準のターミナルやコンソールではなく、指定されたデバイスファイル /dev/pts/0 に送ります。

/dev/pts/0 は、通常、最初に開かれたターミナルや端末セッションを表すデバイスファイルです。したがって、上記のコマンドを実行すると、hello という文字列は現在のターミナルセッション（つまり /dev/pts/0）に表示されることになります。

この方法を使用すると、あるターミナルから別のターミナルにメッセージを送ることができます。ただし、この例では、同じターミナルセッション（/dev/pts/0）にメッセージを送っているので、hello という文字列がそのターミナルに表示されます。





## 通常のユーザーに変更できますか？

はい、root から通常のユーザーに切り替えることができます。

su コマンドを使用して、目的のユーザーアカウントに切り替えることができます。例えば、mitsu30 というユーザーに切り替えたい場合は、以下のコマンドを入力します：

`root@ubuntu:/# su - mitsu30`

上記のコマンドを実行すると、mitsu30 のユーザーセッションが開始されます。

注意点として、su - ユーザー名 のようにハイフンを使用すると、そのユーザーのログインシェルと環境変数がロードされます。
ハイフンなしの su ユーザー名 では、現在のシェルの設定を維持したままユーザーを切り替えます。
どちらを使うかは、具体的なニーズや状況に応じて選択してください。


## キャラクタデバイスとブロックデバイスについて説明してください。

- キャラクタデバイス (Character Device)
  - 逐次的なアクセス: キャラクタデバイスは、データを逐次的（一連の文字列として）に読み書きします。
  -  例: キーボード、マウス、シリアルポートなどがこれに該当します。
         キーボードやマウスからの入力は、文字単位で読み取られるため、キャラクタデバイスとして扱われます。
  -  ランダムアクセス不可: キャラクタデバイスからは、指定された位置から直接データを読み取ることはできません。

- ブロックデバイス (Block Device)
  - ランダムアクセス: ブロックデバイスは、固定されたサイズのデータブロックをランダムに読み書きできます。
  - 例: ハードドライブ、SSD、USBドライブ、CD-ROMドライブなどがこのカテゴリに含まれます。
        これらのデバイスは、データをブロック単位でアクセスし、特定のブロックを直接読み書きすることができます。
  - 高いデータ転送率: 通常、ブロックデバイスは連続したデータブロックを高速に転送できるように最適化されています。

キャラクタデバイスとブロックデバイスの違いは、それぞれのデバイスの使用方法とデータへのアクセスの仕方に基づいています。特に、システムの内部やデバイスドライバの設計、OSのI/O処理において、これらの違いは非常に重要です。



## シークとは

データストレージデバイス上の特定の位置へのアクセスポインタを移動する操作を指します。
シーク操作の目的は、データの読み取りや書き込みを行うための適切な位置にアクセスポインタを配置することです。


以下はシークに関連する具体的なコンセプトや状況:

ハードディスクのシーク: 従来のハードディスクドライブ（HDD）には、データの読み取りや書き込みを行うための可動式のヘッドがあります。このヘッドをディスク上の特定の位置に移動する操作を「シーク」と呼びます。HDDの性能を評価する際の指標として「シークタイム」があり、これはヘッドが指定された位置に移動するのに必要な時間を示します。

ファイルのシーク: プログラミングやファイル操作において、特定の位置にジャンプしてデータを読み取りまたは書き込むために、ファイル内のポインタを移動することも「シーク」と呼ばれます。例えば、C言語のfseek関数やPythonのseekメソッドなど、多くのプログラミング言語やライブラリには、ファイル内でシークを行うための関数やメソッドが提供されています。

シークは、データアクセスの効率やパフォーマンスに影響を与える重要な操作であり、様々なコンテキストで使用される概念です。



キャラクタデバイスとは、ストリームベースのデバイスであり、データをバイトや文字単位で連続的に送受信する特性を持っています。
一方、シーク操作とは、データストレージデバイス上の特定の位置にアクセスポインタを移動する操作を指します。

キーボードを例にとって考えると、以下のように解説できます。

キーボードの動作: キーボードは、キーが押されたときにキーコードや文字を生成し、それをコンピュータに送信します。
　　　　　　　　　このデータ送信は連続的なストリームとして行われ、キーの押下順にデータが送られます。

シーク操作の非適用性: キーボードのようなキャラクタデバイスでは、データが流れるストリームとしての性質を持っているため、
　　　　　　　　　　　特定の位置にジャンプするという「シーク」の概念が適用されません。
　　　　　　　　　　　具体的には、もしキーボードにシーク操作を行おうとすると、どのキーストロークにジャンプしたいのか？あるいは、
　　　　　　　　　　　過去のキーストロークに戻りたいのか？という疑問が浮かび上がります。
　　　　　　　　　　　キーボードは、これらの操作をサポートするようには設計されていません。

具体例: 例えば、ユーザーが"A", "B", "C"の順にキーを押したとします。キーボードはこれらの文字を順番にコンピュータに送信します。
　　　　この送信ストリーム内で「B」の位置にジャンプするようなシーク操作は行えません。
　　　　キーボードからのデータは順番に処理され、一度送信されたデータに後からアクセスすることはできません。

このように、キーボードのようなキャラクタデバイスは、データを連続的なストリームとして送受信する性質を持っており、
特定の位置へのジャンプやアクセスをサポートするシーク操作は適用できません。



## パーティションとは

物理的なハードドライブやSSD（ストレージデバイス）の一部分、もしくは領域を意味します。
パーティションを作成することで、1つの物理的なストレージデバイスを複数の独立したセクションや領域として使用することができます。
各パーティションは独自のファイルシステムを持ち、OSによっては独立したドライブとして認識されることがあります。


## `mkfs.ext4 /dev/sdc7`

指定されたストレージデバイスやパーティション /dev/sdc7 に ext4 ファイルシステムを作成します。

詳細に分解すると以下のようになります：

- mkfs：この部分は "make filesystem" の略で、新しいファイルシステムを作成するためのコマンドです。

- .ext4：これは作成したいファイルシステムのタイプを指定します。ext4 はLinuxの主要なジャーナリングファイルシステムの一つです。
  ジャーナリング機能により、システムクラッシュや突然の電源断などの際にデータの整合性を保ちやすくなっています。

- dev/sdc7：これはファイルシステムを作成する対象のデバイスやパーティションを指定します。
            この場合、/dev/sdc7 という名前のパーティションに ext4 ファイルシステムを作成します。

注意点として、このコマンドを実行すると /dev/sdc7 上の既存のデータはすべて消去されるので、
実行前に重要なデータのバックアップを取っておくことが非常に重要です。



## `mount /dev/sdv7 /mnt/`

/dev/sdv7 という名前のデバイス（通常はストレージデバイスやパーティションを指す）を /mnt/ ディレクトリにマウントします。

詳細に分解すると以下のようになります：

- mount：Linuxおよび多くのUnixベースのオペレーティングシステムで、
  ファイルシステムをディレクトリツリーの特定の位置にアタッチするためのコマンドです。

- /dev/sdv7：マウントしたいデバイスやパーティションを指定します。
  この場合、/dev/sdv7 という名前のパーティションやストレージデバイスを指しています。

- /mnt/：このデバイスやパーティションをマウントする先のディレクトリを指定します。
  /mnt/ は一般的に一時的なマウントのためのディレクトリとして使われます。

このコマンドを実行すると、/dev/sdv7 上のファイルシステムが /mnt/ ディレクトリにマウントされ、
/mnt/ を通じてその内容にアクセスできるようになります。



## マウントとは？

オペレーティングシステムのコンテキストで使用される際に、ストレージデバイス（たとえばハードドライブ、USBドライブ、CD-ROMなど）や
その中のパーティションにあるファイルシステムを、オペレーティングシステムのディレクトリツリーの特定の場所
（マウントポイントとして知られるディレクトリ）に関連付けることを指します。


マウントを行うと以下のことが起こります：

- アクセス可能になる：マウントされたファイルシステムの内容は、指定したマウントポイントを通じてアクセスできるようになります。
                  このため、ディスク上のデータにアクセスするためには、それを先にマウントする必要があります。

- ディレクトリ構造に統合：マウントすることで、物理的なデバイスやパーティションの内容がオペレーティングシステムのディレクトリツリーに統合され、
                      ファイルやディレクトリとして扱うことができます。

- 書き込み・読み取り操作：マウントポイントを通じて、そのデバイスやパーティションにデータを書き込んだり、データを読み取ったりすることができます。

例として、外部のUSBドライブを考えてみましょう。このドライブをコンピュータに接続しても、直ちにその中のデータにアクセスすることはできません。
まず、このドライブをマウントする必要があります。マウントすることで、そのUSBドライブの内容が特定のディレクトリ（マウントポイント）に関連付けられ、
そのディレクトリを通じてドライブの内容にアクセスすることができるようになります。


## `umount /mnt`


umount コマンドは、マウントされているファイルシステムをアンマウント（解除）するためのコマンドです。

指定されたコマンド umount /mnt は、/mnt ディレクトリにマウントされているファイルシステムをアンマウントするという意味になります。

具体的には、以下の動作が行われます：

/mnt に関連付けられたストレージデバイスやそのパーティションとの関連を解除します。
その後、/mnt は空のディレクトリとして扱われ、マウント前の状態に戻ります。
アンマウント後、そのストレージデバイスやパーティションの内容には、/mnt というディレクトリを通じてアクセスできなくなります。
このコマンドは、特に外部デバイスを安全に取り外す前や、システムのメンテナンス作業を行う前に、
マウントされているファイルシステムを適切にアンマウントするために使用されます。


## `dd if=testfile-overwrite of=/dev/sdc7 seek=$((0*803d000)) bs=1`

この dd コマンドは、特定のファイルからデータを読み取り、それを指定されたデバイスに書き込むことでデータをコピーします。
各オプションの意味を詳しく見てみましょう。

- if=testfile-overwrite：if は "input file" の略で、ここでは testfile-overwrite というファイルからデータを読み取ることを意味しています。

- of=/dev/sdc7：of は "output file" の略で、ここでは /dev/sdc7 というデバイスにデータを書き込むことを指示しています。

- seek=$((0*803d000))：seek オプションは、出力ファイル内での開始位置を指定します。しかし、ここでの式 0*803d000 は 0 に評価されるため、
  実質的にこのオプションは意味がありません。通常、seek はデータを書き込む開始位置をバイト単位で指定するために使用されます。

- bs=1：bs は "block size" の略で、このコマンドでは1バイトごとにデータを読み取り、書き込むことを意味しています。

合わせて解釈すると、このコマンドは testfile-overwrite からデータを読み取り、
そのデータを /dev/sdc7 というデバイスに1バイトずつ書き込んでいきます。
