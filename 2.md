# 2章

## `ps aux --no-header | wc -l`
実行中のプロセスの数をカウントするためのものである。
- `ps aux`
  - ps: プロセスのステータスを表示するコマンドです。
  - aux: オプションです。
    - a: すべてのターミナルからのプロセスを表示します。
    - u: ユーザー/オーナー情報を含む詳細な表示をします。
    - x: ターミナルに関連しないプロセスも表示します。

- `--no-header`: ps コマンドの出力からヘッダー行を除外します。
コマンドの出力からヘッダー行を除外する。

- `|`: パイプ記号です。この記号は、前のコマンドの出力を次のコマンドの入力として使用します。

-  `wc -l`:
  - wc: "word count" の略で、テキストの行数、単語数、文字数をカウントするコマンドです。
  - -l: オプションで、行数だけをカウントします。

したがって、このコマンドは、システム上で現在実行中のプロセスの総数（ヘッダーを除く）をカウントして表示します。


## fork()関数から復帰するとはどういう意味ですか？
fork()関数は、新しいプロセス（子プロセス）を作成するためのシステムコールです。
この関数が特徴的なのは、一度呼び出すと二度復帰するという点です。これは少し直感的でないかもしれませんので、詳しく説明します。

fork()関数を呼び出すと、以下のようになります：
- 親プロセス：fork()は子プロセスのプロセスID (PID) を返します。このPIDは正の整数値です。
- 子プロセス：fork()は0を返します

したがって、fork()関数の後にコードを書くと、そのコードは親プロセスと子プロセスの両方で実行されます。
しかし、fork()の返り値を使って、どちらのプロセスで実行されているのかを判断することができます。
そのため、多くの場合、返り値をチェックして、親プロセスと子プロセスで異なる動作をさせることが一般的です。

「fork()関数から復帰する」とは、この関数が呼び出された後、新しい子プロセスが作成され、
親プロセスと子プロセスの両方が続くコードを実行することを意味します。
復帰の際の振る舞い（返り値）が異なるため、この振る舞いの違いを利用して、それぞれのプロセスでどのような動作をさせるかを制御することができます。


## `cc -o pause -no -pie pause.c`
- `-no -pie:`
コンパイラオプションの一つで、Position Independent Executables (PIE) の生成を無効にするためのものです。まず、PIE自体について少し説明します。

Position Independent Executables (PIE)
プログラムがASLRに対応している。このようなプログラムをPIEと呼ぶ。

- PIEは実行時にメモリ上の任意の位置にロードされることができる実行ファイルです。
- PIEはPosition Independent Code (PIC) の概念を実行ファイルに拡張したものです。PICは共有ライブラリのコンテキストでよく使われます。
- PIEの主な利点は、Address Space Layout Randomization (ASLR) の効果を強化することです。
ASLRはセキュリティの機構の一つで、メモリ上のオブジェクトの位置をランダム化することで、
バッファオーバーフローや他のメモリ関連の攻撃をより困難にします。

-no-pie オプションの役割：

一部のシステムやコンパイラのバージョンでは、デフォルトでPIEが有効になっていることがあります。
このような環境でPIEを無効にしたい場合に、-no-pie オプションを使用します。
PIEを無効にする理由はいくつかあります。
例えば、特定のメモリアドレスに依存するような古いソフトウェアや、デバッグを簡単にするため、
あるいは特定のハードウェアや組み込みシステムの制約などが考えられます。
したがって、-no-pie オプションを使うことで、PIEの生成を無効にし、実行ファイルが固定のメモリアドレスにロードされるようになります。


## `readelf -h pause` 
ELF (Executable and Linkable Format) フォーマットのファイルの情報を表示するためのツールです。
ELFフォーマットは、多くのUNIX系オペレーティングシステムで実行ファイル、共有ライブラリ、
さらにはいくつかのコアダンプで使用される標準的なバイナリフォーマットです。

- h: このオプションはELFヘッダの情報を表示するように指示する。ELFファイルの基本的な属性、例えばファイルが32ビットなのか
　　　64ビットなのかなどの情報を提供する。


## メモリマップとは
execve()関数の引数で指定した実行ファイルからプログラムを読み出して、メモリ上に配置することを
メモリマップと呼ぶ。


## エントリーポイントとは
実行ファイルや共有ライブラリの中で実際にプログラムの実行が開始されるメモリアドレス、またはその位置を指す。
具体的にはプログラムが実行されるときに最初に実行される命令のアドレスを指す。


## オフセットとは
基準となる位置や開始点からの相対的な距離や位置を示す値である。
例えば
-  メモリ：ある基準となるメモリアドレスからの相対的な位置を示す。例えば配列の先頭のアドレスが基準となり、
　　　　　　配列の各要素はその先頭からのオフセットとしてアクセスされることが多い。

- ファイル：ファイルの特定の部分を参照するとき、その開始位置からのオフセットを使用して位置を指定することがある。
　　　　　　例えば、バイナリファイルの中央部にあるデータを読むためにオフセットを使用して読み取り位置を移動することができる。


## `./pause &`
- &: コマンドの終わりに配置され、シェルに対してコマンドをバックグラウンドで実行するように指示する。
　　　このオプションを使用するとコマンドはバックグラウンドで実行されるため、ユーザーはすぐにシェルのプロンプトを再度受け取ることができる。


## シェルとは
ユーザーとオペレーティグシステムのカーネルとの間のインターフェイスとして機能するソフトウェアのことである。
通常、コマンドラインインターフェース（CLI）を提供し、ユーザーがテキストコマンドを入力して、プログラムを実行したり、
システムタスクを管理したりすることができる。


## ファームウェアとは
ハードウェアデバイスを制御するためのソフトウェアの一種で、そのハードウェアデバイスのROM、EPROM、フラッシュメモリなどの
非揮発性メモリに格納されています。ファームウェアは、ハードウェアが正常に機能するための基本的な低レベルの制御、初期化、および管理を提供します。


## ブートローダとは
コンピュータの起動時に実行される特殊なプログラムで、
オペレーティングシステムのカーネルや初期システムをディスクや他のストレージからRAMに読み込む役割を持っています。
ブートローダは、BIOSやUEFI（新しいタイプのBIOSのようなもの）によって最初に呼び出されるもので、
コンピュータの電源が投入された後や再起動時に実行されます。

- 初期化: ブートローダは、オペレーティングシステムを読み込む前の初期のハードウェア初期化タスクを実行します。
- オペレーティングシステムの選択: マルチブート環境（複数のオペレーティングシステムが同一のコンピュータにインストールされている場合）では、
  ブートローダを使用して起動したいオペレーティングシステムを選択することができます。
- カーネルの読み込み: ブートローダの主要な役割の一つは、オペレーティングシステムのカーネルをストレージデバイスからRAMに読み込むことです。
- オプションの渡し: ブートローダは、特定のパラメータやオプションをオペレーティングシステムのカーネルに渡すことができます。
  これにより、特定のモードでの起動やデバッグ作業などが行えます。
- 回復モード: 一部のブートローダは、システムの問題を診断したり修復したりするための特別な回復モードを提供することもあります。


## CPUとは
CPUは、コンピュータの「脳」のようなものです。主な役割は、プログラムの命令を読み込み、それを解釈し、実行することです。以下はCPUの主な特徴と役割です。

- 命令の実行: CPUは、アプリケーションやオペレーティングシステムからの命令を連続的に実行します。
- クロック速度: CPUの性能はクロック速度（GHzなどの単位で示される）によって部分的に決まります。
  これは、CPUが1秒間に何回命令を処理できるかを示します。
- コア数: 現代の多くのCPUはマルチコアを持っており、それにより複数の命令を同時に実行することができます。
- キャッシュメモリ: CPUは、頻繁にアクセスするデータや命令を高速にアクセスできる小さなメモリ（キャッシュ）を持っています。

##  メモリとは
メモリは、コンピュータの「短期記憶」のようなものです。アプリケーションやシステムは、実行中に一時的なデータをメモリに保存します。
以下はメモリの主な特徴と役割です。

- 一時的なストレージ: メモリは電源がオフになると内容が失われる一時的なストレージです。
- 高速アクセス: メモリはストレージデバイス（HDD、SSDなど）よりもずっと高速にデータにアクセスすることができます。
- 容量: メモリの容量は、一度に処理できるデータの量や、同時に実行できるアプリケーションの数に影響します。
- アプリケーションの実行: アプリケーションを実行する際、そのプログラムのコードとデータはメモリにロードされます。

## 例え話
CPUは労働者のようなもので、メモリは彼の作業台です。労働者が多くの道具や材料をすぐに手に取れるように、
作業台に配置することで、効率的に仕事を進めることができます。
この作業台が小さすぎると、労働者は道具や材料を頻繁に取り替えなければならず、効率が落ちます。
この労働者（CPU）が速く動けるほど、そして作業台（メモリ）が大きいほど、仕事の効率が上がります。


## bashとは
UnixおよびUnix系オペレーティングシステム用のシェル、つまりコマンドラインインターフェースの一つです。

以下は、bashの主な特徴や機能です：

- コマンドライン編集: ユーザーはコマンドラインでの入力を編集したり、以前のコマンドを再利用したりすることができます。
- ジョブ制御: バックグラウンドでのコマンド実行や、実行中のジョブの一時停止・再開が可能です。
- 履歴機能: 実行したコマンドの履歴を保存・参照することができます。
- シェルスクリプト: 条件分岐、ループ、変数、関数などのプログラミング機能を利用して、タスクの自動化を行うスクリプトを作成できます。
- コマンドの置換: コマンドの出力を別のコマンドの入力として利用することができます。
- 拡張されたグロブ機能: ワイルドカードを使用して、ファイル名のマッチングやパターンマッチングを行うことができます。
- エイリアス: 長いコマンドや頻繁に使用するコマンドに対して短い名前を設定できます。

bashは、多くのLinuxディストリビューションやmacOSなどのシステムでデフォルトのシェルとして利用されています。


## どうして以下のファイルの実行結果が1になるのか？
falseコマンドの終了ステータスが1であるためです。

```
#!/bin/bash

false &
wait $! # false\u30d7\u30ed\u30bb\u30b9\u306e\u7d42\u4e86\u3092\u5f85\u3061\u5408\u308f\u305b\u308b\u3002false\u30b3\u30de\u30f3\u30c9\u306ePID\u306f`$!`\u5909\u6570\u304b\u3089\u5f97\u3089\u308c\u308b
echo "false\u30b3\u30de\u30f3\u30c9\u304c\u7d42\u4e86\u3057\u307e\u3057\u305f: $?" # wait\u5f8c\u306bfalse\u30d7\u30ed\u30bb\u30b9\u306e\u623b\u308a\u5024\u306f`$?`\u5909\u6570\u304b\u3089\u5f97\u3089\u308c\u308b\u3002
```

```
mitsu30@ubuntu:~/Linux/linux-in-practice-2nd/02-process-management-1$ ./wait-ret.sh
false\u30b3\u30de\u30f3\u30c9\u304c\u7d42\u4e86\u3057\u307e\u3057\u305f: 1
```


## ゾンビプロセスとは
ゾンビプロセスは、終了したがその終了ステータスが親プロセスによってまだ収集されていないプロセスを指します。
以下に、ゾンビプロセスの特徴と成り立ちについて詳しく説明します。

- ゾンビプロセスの特徴:
  - リソース: ゾンビプロセスはCPUリソースを使用しません。ただし、プロセステーブルにエントリが残るため、
            このテーブルが一杯になった場合に新しいプロセスの生成が妨げられる可能性があります。

  -  終了ステータス: ゾンビプロセスはその終了ステータスを親プロセスに報告するために存在します。
                   親プロセスが終了ステータスを収集すると、ゾンビプロセスはシステムから完全に削除されます。

  - 表示: psコマンドを使用してプロセスをリストするとき、ゾンビプロセスは通常Zというステータスで表示されます。

- ゾンビプロセスができる理由:
子プロセスが終了し、その終了ステータスをOSに報告します。
OSは終了ステータスを一時的に保持し、親プロセスがそれを収集するのを待ちます。
しかし、親プロセスが適切なシステムコール（例: wait()やwaitpid()）を使用して子プロセスの終了ステータスを収集しない場合、
子プロセスのエントリはプロセステーブルに残ったままになります。この状態の子プロセスが「ゾンビプロセス」となります。

- ゾンビプロセスの取り扱い:
通常、親プロセスは子プロセスの終了ステータスを収集すべきです。
もし親プロセスが終了ステータスを収集しない場合、ゾンビプロセスはinitプロセス（PID 1のプロセス）の子プロセスとして再親子関係が結ばれ、
initがその終了ステータスを収集します。
要するに、ゾンビプロセスはシステムの動作に害を及ぼすものではありませんが、
プログラムのバグや不適切なリソース管理が原因で発生することが多いため、ゾンビプロセスの存在はそのような問題の指標となることがあります。


##  フォアグラウンドジョブとは
シェルやターミナルのセッションで直接実行され、ユーザーの入力や操作を待機・受け付けるジョブやプロセスを指します。
フォアグラウンドジョブは、起動された時点でターミナルの制御を取得し、ユーザーとのインタラクションを継続します。
この間、通常はターミナル上での他の操作は一時的に停止します。


## SSHとは
SSH(Secure Shell)は、ネットワークを介して別のコンピュータに安全にアクセスするためのプロトコルです。
SSHは暗号化技術を使用して通信内容の安全性を確保し、ユーザー認証やコマンド実行、ファイル転送などの機能を提供します。

- SSHの主な用途:
  - リモートシェルアクセス: SSHを使用して、リモートのマシンにログインし、シェルのセッションを開始できます。
  - ファイル転送: scpやsftpなどのツールを使って、ローカルマシンとリモートマシンの間でファイルやディレクトリを安全に転送できます。
  - リモートコマンド実行: SSHを使用して、リモートのマシンで特定のコマンドやスクリプトを実行できます。
  - ポートフォワーディング: SSHトンネリングとも呼ばれるこの機能は、特定のネットワークポートのトラフィックをSSH接続を介して転送することができます。

- SSHの主な特長:
  - セキュリティ: SSHは強固な暗号化を使用して、セッション内のすべての通信を保護します。
  - 認証: SSHは、パスワードベースの認証やより安全な公開鍵認証をサポートしています。
  - 可用性: 多くのオペレーティングシステム（Linux, macOS, Windowsなど）で使用可能です。


## HTTPとの違いは？
それぞれ異なる目的のために設計されたプロトコルである。

- 目的:
  - SSH: SSHは、ネットワークを介して別のコンピュータに安全にアクセスするためのプロトコルです。
         リモートシステムへのログイン、コマンドの実行、ファイル転送などが主な用途です。
  - HTTP: HTTPは、ウェブサーバとクライアント（通常はウェブブラウザ）の間の情報のやり取りを行うためのプロトコルです。
          ウェブページや関連するリソース（画像、動画、スタイルシートなど）の取得が主な用途です。
- セキュリティ:
  - SSH: 通信内容全体が暗号化されています。これにより、通信を傍受しても内容を簡単には読み取れません。
  - HTTP: 標準のHTTPは暗号化されていませんが、HTTPS（HTTP over SSL/TLS）という安全なバージョンも存在し、この場合は通信内容が暗号化されます。
- ポート番号:
  - SSH: デフォルトのポート番号は22です。
  - HTTP: デフォルトのポート番号は80、HTTPSの場合は443です。
- 使用されるアプリケーション:
  - SSH: リモートシェルアクセス、ファイル転送（scp, sftp）、ポートフォワーディングなど。
  - HTTP: ウェブブラウジング、ウェブAPIのリクエスト、ウェブベースのアプリケーションなど。
- 接続の維持:
  - SSH: SSHセッションは、ユーザーが切断するかタイムアウトするまで維持されます。
  - HTTP: HTTPはステートレスなプロトコルであり、リクエストごとに新しい接続が確立され、
    レスポンスの後には通常切断されます（HTTP/1.1のkeep-aliveやHTTP/2の多重化など、一部の例外もあります）。


## GitHubで両方使えますけど
確かにSSHとHTTPSの両方のプロトコルを選択できます。それらは異なる目的で設計されているものの、
Gitのクローンやプッシュというコンテキストでは、どちらもリポジトリへの安全なアクセス手段として機能します。
以下に、Gitのクローンやプッシュに関するSSHとHTTPSの主な違いと利点を示します。

- 認証:
  - SSH: 公開鍵/秘密鍵のペアを使用して認証します。正しい秘密鍵を持っているユーザーのみがリポジトリにアクセスできます。
       これにより、パスワードを毎回入力する必要がなくなります。
  - HTTPS: ユーザー名とパスワード、もしくはトークン（Personal Access Token）を使用して認証します。
         GitHubは2021年8月以降、パスワードを使用したHTTPSクローンやプッシュを非推奨としており、代わりにトークンを使用することを推奨しています。
- セットアップの簡単さ:
   -  SSH: 初めて使用する場合、公開鍵/秘密鍵のペアを生成し、公開鍵をGitHubにアップロードする必要があります。
   -  HTTPS: 公開鍵/秘密鍵のペアのセットアップは不要ですが、
             クローンやプッシュの際に認証情報を提供する必要があります（キャッシュツールを使用すれば入力の頻度を減らすことができます）。
- ファイアウォールとプロキシ:
  - SSH: ポート22を使用するため、一部の企業のネットワークではブロックされることがあります。
  - HTTPS: ポート443を使用するので、多くのネットワークやプロキシ環境でも問題なく動作します。
- セキュリティ:
両方のプロトコルともに、通信は暗号化されます。したがって、通信内容の傍受リスクは低いです。
どちらのプロトコルを選択するかは、ユーザーの環境や好みに依存します。たとえば、頻繁にリポジトリにプッシュする場合、SSHを使用してパスワードの入力を避けることができます。一方、企業のネットワーク内など特定の環境ではHTTPSが適している場合もあります。


## `ps ajx` 
- j: ジョブの情報を表示します。これにはセッションID、プロセスグループID、前景プロセスグループID、
  そしてターミナルのプロセスグループIDが含まれます。

PPID: 親プロセスのID。
PID: プロセスID。
PGID: プロセスグループID。
SID: セッションID。
TTY: 端末の名前
その他: タイムスタンプ、コマンド名、ステータスなどの情報。


## ハングアップとはなんですか
UNIXやLinuxのコンテキストでのハングアップ:

UNIXやLinuxの世界では、ハングアップは、端末や通信セッション（例: SSHセッション）が切断されたことを示すシグナル（SIGHUP）を指すこともあります。
これは、伝統的にモデム接続が切断される（ハングアップする）ことを模倣したものです。多くのデーモンやプロセスは、このシグナルを受け取ると、
再起動するか、設定を再読み込みすることが一般的です。


## `ps ajx | less`
- less:less コマンドは、テキストファイルやコマンドの出力をページング表示するツールです。
       less を使用すると、長い出力内容を1ページずつスクロールして表示することができ、
       キーボードの矢印キーや検索機能などを使用して内容をナビゲートすることができます。
