# 3章

## `for i in 1 2 3 ; do ./sched.py $i ; done`

 `1. for i in 1 2 3 ; do ... ; done`

これはbashのforループの基本的な構文です。この構文は、指定されたリスト（この場合は1 2 3）の各要素に対して
その中にあるコマンドを繰り返し実行します。

この例では、変数iが1から3までの値を順に取り、do ... doneの間にあるコマンドを実行します。


## ` sysctl kernel.sched_latency_ns`

- sysctl: sysctlは、Linuxシステムのカーネルパラメータを読み書きするためのコマンドラインツールです。
          これらのパラメータは、システムの動作やパフォーマンスを調整するためのもので、/proc/sys/ディレクトリ内に存在します。

- kernel.sched_latency_ns: これはカーネルのスケジューリングパラメータの一つです。
                           具体的には、完全なタスクのスケジューリング期間を定義するもので、
                           この期間内に全ての実行可能なタスクが少なくとも一度は実行されるようになります。値はナノ秒で表示されます。


## レイテンシターゲットとは
この期間に一度、CPU時間を得ることができる。


## `nice -n 5 taskset -c 0 ./inf-loop.py &`

nice -n 5:

niceコマンドは、プロセスの優先度を変更して実行するためのツールです。
-n 5オプションは、デフォルトの優先度よりも5点低く設定することを意味します。この優先度の範囲は-20（最も高い優先度）から19（最も低い優先度）までです。したがって、このコマンドは、通常よりも低い優先度でプロセスを実行します。

taskset -c 0:

tasksetは、プロセスを特定のCPUコアに束縛するためのツールです。
-c 0オプションは、プロセスをCPUのコア0にのみ割り当てることを意味します。

まとめると、このコマンドはinf-loop.pyスクリプトをCPUのコア0上で低い優先度（nice値5）でバックグラウンドで実行します。


## `sar -P 0 1 1`

sar は、Sysstat パッケージに含まれるシステムのパフォーマンスモニタリングツールです。
このツールは、システムのさまざまなリソースに関する統計を収集して表示します。

-P 0 1 1 オプションは、特定のCPU（この場合はCPU 0）の使用状況を収集することを指定します。以下は、各オプションの説明です：

-P 0: CPU 0 の統計情報のみを表示することを指定します。
1: 収集間隔を1秒に設定します。
1: 総計1回のデータ収集を行うことを指定します。
したがって、sar -P 0 1 1 コマンドは、CPU 0 の使用状況を1秒間隔で1回収集し、その結果を表示します。

%userと%niceの合計によってユーザモードでプロセスを実行している時間の割合を得ることができる。


## スレッドについて
「スレッド」とは、コンピュータのプログラム実行の単位を指します。
プロセスはシステム上で実行される個別のプログラムのインスタンスであり、スレッドはそのプロセス内での実行の単位となります。

マルチコアのCPUやマルチCPUのシステムでは、複数のスレッドを同時に実行することが可能です。
これにより、タスクの並列化やパフォーマンスの向上が期待できます。

- 「4コア4スレッド」: これは各コアが1つのスレッドを処理することを意味します。
- 「4コア8スレッド」: これは各コアが2つのスレッドを同時に処理することを意味します。


## `grep -c processor /proc/cpuinfo`

grep -c processor /proc/cpuinfo: このコマンドは/proc/cpuinfoというファイルを検索し、
processorという文字列が何行に現れるかをカウントします。

/proc/cpuinfo: このファイルはLinuxシステムにおいて、CPUに関する詳細情報を提供する特殊なファイルです。
このファイルには、システム上のすべてのCPUコア（またはスレッド）に関する情報が含まれており、
各コア（またはスレッド）にはprocessorというエントリがあります。

grep -c: これはgrepコマンドのオプションで、指定されたパターンにマッチする行数をカウントします。

結果として、このコマンドはシステム上のCPUのコア数（またはスレッド数）を出力します。
ハイパースレッディングが有効になっている場合、物理的なコア数よりも多くのスレッド数が表示されることがあります。


## スループットについて
応答性重視のシステムとスループット重視のシステムは、その性質上、異なる設計の考慮事項や最適化のポイントを持っています。
以下に、応答性重視のシステムでCPU使用率を低めに抑える理由を示します。

- タスクの待ち時間の最小化: 応答性を高めるためには、新しいタスクや割り込みが来たときに迅速に対応する必要があります。
  もしCPU使用率が高いと、新しいタスクの処理開始までの遅延が発生しやすくなります。

- 予測可能性の確保: 応答性が要求されるシステム（例：リアルタイムシステム）では、タスクが予測可能な時間内に完了することが求められることが多い。
                 高いCPU使用率はその予測可能性を低下させるリスクがあります。

- 突発的な負荷の増加への対応: 応答性重視のシステムは、突然の負荷の増加や予期しないイベントに迅速に対応する必要があります。
                          CPU使用率が常に高いと、このような突発的な状況に適切に対応するのが難しくなります。

- ユーザ体験の向上: 応答性が要求されるアプリケーション（例：ユーザインターフェースやゲーム）では、
                 ユーザのアクションに対して迅速に反応することが求められます。適切なCPU使用率の確保は、滑らかで快適なユーザ体験のために重要です。

一方、スループット重視のシステムでは、最大限のリソースを使用して最大量のタスクを一定時間内に処理することが重要です。したがって、高いCPU使用率はこの目的を達成するために望ましいとされることが多いです。

要するに、システムの目的と要件に応じて、適切なCPU使用率やリソースの利用戦略を選択することが重要です。


## 「論理CPUをたくさん積んでいるマシンがあったとしてもそこに十分な数のプロセスを実行させて初めてスループットが向上する。」

- 論理CPUが多いということは、同時に複数のタスクを並行して処理できる可能性が高まります。
- しかし、論理CPUの数だけプロセスやスレッドが存在しない場合、その全てのCPUを効率的に使用することは難しい。
  つまり、たとえ8つのコアがあったとしても、実行すべきプロセスが1つだけであれば、7つのコアはアイドル状態となり、その潜在的な能力は生かされません。
- 逆に、十分な数のプロセスが実行されている場合、それらのプロセスは複数のコアに分散されて実行され、
  スループット（単位時間あたりの処理能力）が向上します。

## 「むやみにプロセス数を増やしてもスループットは上がらない。」

- システムのスループットは、プロセス数が増えることで向上する可能性がありますが、ある一定の限界を超えると逆に低下することがあります。
- これは「コンテキストスイッチ」と呼ばれるCPUのタスク切り替えが頻繁に発生し、それに伴うオーバーヘッドが増加するためです。
- また、多数のプロセスが同時に動作する場合、メモリやI/Oなどのリソース競合が生じることがあり、これも性能を低下させる要因となります。
