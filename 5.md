# 5章

## エントリポイントとは

エントリポイント（EntryPoint）とは、プログラムやソフトウェアアプリケーションが開始される際に、
最初に実行される位置や関数のことを指します。これは、プログラムがどこからスタートすれば良いのかを示す指標や起点となる部分です。

## ddコマンド

dd コマンドは、UnixおよびLinuxシステムにおいて、特定のブロックサイズでデータを変換およびコピーするためのツールです。その名前は「data definition」または「convert and copy」から来ています。このツールは、ファイルやデバイス間でデータを移動したり、データの変換やフォーマットの変更を行ったりする際に非常に便利です。

以下は、dd コマンドの基本的な使用方法と一般的なオプションを示す例です。

基本的な構文:

`dd if=<入力ファイル> of=<出力ファイル> [オプション]`
主なオプション:

- if=: 入力ファイルまたはデバイスを指定します。
- of=: 出力ファイルまたはデバイスを指定します。
- bs=: ブロックサイズを設定します。これは、一度に読み書きするバイト数を指定します。
- count=: コピーするブロック数を指定します。
- skip=: 入力ファイルまたはデバイスからスキップするブロック数を指定します。
- seek=: 出力ファイルまたはデバイスでのスキップするブロック数を指定します。


使用例:

ディスクからディスクへのコピー:
`dd if=/dev/sda of=/dev/sdb bs=4M`
ディスクイメージの作成:
`dd if=/dev/sda of=/path/to/image.img bs=4M`
ファイルの内容を標準出力に出力:
`dd if=/path/to/file bs=1M count=10`
注意点:

dd コマンドは非常に強力なツールであるため、特にディスクやデバイスに直接書き込む際には十分に注意が必要です。誤ってデータを上書きしたり、ディスクを破損させる可能性があります。
dd コマンドの進捗を表示するには、status=progress オプションを追加できます。
dd コマンドは、多くのシステム管理タスクにおいて非常に役立つツールですが、その強力さゆえに注意深く使用する必要があります。



## `free | awk 'NR==2{print $2}'`
`awk 'NR==2{print $2}'`: このコマンドはAWKプログラムの一部です。

NR==2: AWKの特殊変数で、現在の行番号を意味します。この条件は2行目のときに真となります。
{print $2}: このアクションは上記の条件が真の場合に実行され、2列目の値を表示します。
このコマンドの結果として、free コマンドの出力から2行目の2列目の値、すなわちシステムの合計メモリ量（total）が表示されます。


## AWKプログラムとはなんですか？

AWKは、テキスト処理用のプログラミング言語であり、テキストファイル内のパターンを検索し、
そのパターンにマッチする行に対して特定のアクションを実行するためのツールです。
AWKは、名前が示すように、Aho、Weinberger、Kernighanの3人の発明者のイニシャルから取られています。

AWKの主な特徴と用途は以下の通りです：

- テキスト処理: AWKは、テキストファイルを行ごとに処理し、各行をフィールドに分割して操作するのに適しています。

- パターンマッチング: AWKは、特定のパターンまたは条件にマッチする行を検索するために使用できます。

- 内蔵の変数: 例えば、NR（現在の行番号）やFS（フィールドセパレータ）のような多くの内蔵変数があります。

- 算術と文字列操作: 基本的な算術操作や文字列関数を持っています。

- 連想配列: AWKには連想配列があり、キーと値のペアを保存するのに役立ちます。

AWKプログラムは、基本的に「パターン { アクション }」という形式で書かれます。パターンが真の場合（または指定された場合）、関連するアクションが実行されます。

例えば、以下のAWKプログラムは、テキストファイル内の行が5文字以上の場合にその行を表示します。

`awk 'length($0) > 5' filename.txt`
この例では、length($0) は現在の行の長さを返し、それが5より大きい場合に行が表示されます。

AWKは非常に強力なツールであり、UNIXやLinuxの環境でのテキスト処理において多用されています。


## `echo  0 >  count`
- echo 0: 0 という数字を出力します。
- >: これはリダイレクトを意味します。左側のコマンドの出力を右側のファイルに書き込みます。
- count: 出力先のファイル名です。

もし count というファイルが既に存在していた場合、このコマンドを実行するとその内容は上書きされ、新しい内容として 0 だけが書き込まれます。もし count という名前のファイルが存在しない場合は、新しく作成されます。



## `for ((i=0;i<1000;i++)); do ./inc.sh; done`

for ループの文法において、do と done が必要です。


## `for((i=0;i<1000;i++)) ; do ./inc.sh & done; wait`

このコマンドは、inc.sh というシェルスクリプトを1000回並列で実行しています。そして、すべての実行が終了するまで待機します。

for((i=0;i<1000;i++)): これはCスタイルのforループを使用しています。iという変数が0から始まり、
999になるまで繰り返されます。つまり、ループの内部のコマンドは1000回実行されます。

do ... done: これはforループの本体を囲むための構文です。

./inc.sh &: このコマンドはカレントディレクトリにあるinc.shというシェルスクリプトをバックグラウンドで実行します。
&がついているため、シェルは新しいプロセスをバックグラウンドで起動し、
すぐに次のイテレーションやコマンドの実行に移ります。このため、inc.shが1000回ほぼ同時に起動されることになります。

wait: これはシェル組み込みのコマンドで、バックグラウンドで実行されているすべてのジョブが終了するのを待ちます。
このコマンドのおかげで、inc.shが1000回すべて終了するまで、次のコマンドやシェルのプロンプトに移らないようになります。

総合的に、このコマンドはinc.shを1000回並列で起動し、すべての実行が終了するまで待機します。


## `for ((i=0;i<1000;i++)) ; do ./inc-wrong-lock.sh & done; for ((i=0;i<1000;i++)); do wait; done`

このコマンドは2つのforループを使用して、inc-wrong-lock.shというシェルスクリプトを1000回バックグラウンドで並列実行した後、
それらのすべてが終了するまで待機します。

最初のforループ:

for ((i=0;i<1000;i++)): Cスタイルのforループを使用して、0から999までの整数を繰り返し処理します。ループ内のコマンドは1000回実行されます。
do ./inc-wrong-lock.sh &: inc-wrong-lock.shというシェルスクリプトをバックグラウンドで実行します。
&がついているので、シェルは新しいプロセスをバックグラウンドで起動し、すぐに次のイテレーションに移ります。
これにより、inc-wrong-lock.shが1000回ほぼ同時に実行されます。

次のforループ:

for ((i=0;i<1000;i++)): 同様に、このCスタイルのforループも1000回繰り返されます。
do wait; done: ここで使用されているwaitコマンドは、子プロセスが終了するのを待機するためのものです。
この場合、waitは最初に終了した子プロセスを1つ待機し、それが終了すると次の子プロセスを待機します。
このループを1000回繰り返すことで、先のループで起動された1000個のinc-wrong-lock.shプロセス全てが終了するのを待機します。

この2つのforループの組み合わせにより、inc-wrong-lock.shが1000回並列で実行され、そのすべてが終了するまで待機することが実現されています。


## アセンブリ言語とは？

アセンブリ言語（Assembly language）は、低レベルプログラミング言語の一つで、特定のコンピュータアーキテクチャ向けに設計されています。
アセンブリ言語は機械語に非常に近いため、人間が理解しやすい形で機械語に直接的な操作を行うことができます。

アセンブリ言語の特徴：

- マシンコードと1対1で対応する命令が存在する。
- コンピュータのハードウェア、特にCPUに密接に関連している。
- アセンブリ命令は、アセンブラというツールを使用して直接的な機械語のバイナリコードに変換される。
- アセンブリは、高レベルのプログラミング言語と比べて書くのが難しく、また実行速度やメモリ使用量の最適化が求められる場合や、
  ハードウェアに直接アクセスが必要な場合など、特定のニーズを満たすために使われます。


## 高レベルと低レベルとはどういった意味を指していますでしょうか？

プログラミング言語の抽象度や直接的なハードウェア操作の容易さを示しています。

高レベル言語:

- 抽象度が高い: プログラマーがコードを書く際に、具体的なハードウェアの詳細を気にする必要が少ない。
- シンプルで読みやすい: 多くの高レベル言語は、自然言語に近い構文を持っており、意図が理解しやすい。
- 移植性が高い: 一度書いたコードを、さまざまなハードウェアやオペレーティングシステムで実行できることが多い。
例: Python, Java, Ruby, C++ など。

低レベル言語:

- 抽象度が低い: プログラマーは、特定のハードウェアやアーキテクチャの詳細を知っている必要がある。
- 直接的なハードウェア制御: CPUのレジスタやメモリアドレスなど、ハードウェアの具体的なリソースを直接操作することができる。
- 移植性が低い: 低レベル言語で書かれたコードは、特定のハードウェアやアーキテクチャでのみ動作することが多い。
例: アセンブリ言語。

言葉としての「高」と「低」は、品質や能力の程度を示しているわけではなく、あくまで抽象度の違いを示しています。高レベル言語は開発の速度やコードの保守性に優れることが多く、低レベル言語はハードウェアの詳細な制御や高いパフォーマンスの実現が可能です。使用する言語は、目的やニーズに応じて選ぶ必要があります。


## スレッドとは

プロセスの実行単位の一つで、軽量な"サブプロセス"とも言えます。スレッドは、プロセス内で複数のタスクを同時に実行するための仕組みを提供します。

以下に、スレッドに関する主な特徴や概念を列挙します：

- 共有されるメモリ: 同じプロセス内の複数のスレッドは、メモリ空間（ヒープ、グローバル変数など）を共有します。
                これにより、スレッド間のデータの通信や共有が容易になりますが、同時にデータの一貫性や同期の問題も生じる可能性があります。

- 独立したスタック: 各スレッドは独自のスタック領域を持ちます。これにより、関数呼び出しやローカル変数の管理が行われます。

- 効率的なコンテキストスイッチ: スレッド間のコンテキストスイッチ（実行するスレッドを切り替える操作）は、
                           プロセス間のコンテキストスイッチよりも通常、効率的に行われます。

- 同時実行: マルチコアまたはマルチプロセッサのシステムでは、複数のスレッドを真に同時に実行することが可能です。

- 同期: スレッド間でデータを共有する場合、同期のための手段（ミューテックス、セマフォ、バリアなど）が必要になります。
       これは、複数のスレッドが同時に共有データにアクセスすることによる競合や不整合を防ぐためです。

生成と終了: スレッドの生成と終了は、プロセス全体の生成や終了に比べて、比較的低コストで行えます。

スレッドを使用することで、特定の種類のアプリケーション
（例えば、高度なユーザーインターフェースを持つアプリケーションや並列処理を行うアプリケーション）
のパフォーマンスやレスポンス性を向上させることができます。
ただし、スレッドを適切に管理・同期しないと、バグやデータの不整合が発生するリスクも高まります。


## カーネルスレッドとユーザスレッドについて

- カーネルスレッド (Kernel-level Threads)：
  - カーネル管理: カーネルスレッドはOSカーネルによって直接管理されます。
                これは、カーネルがスレッドの生成、スケジューリング、終了などの操作を直接制御することを意味します。

  - コンテキストスイッチのコスト: カーネルスレッド間でのコンテキストスイッチは、ユーザスレッドに比べてやや重いです。
                              カーネルに切り替える必要があるため、コンテキストスイッチのコストがかかります。

  - マルチプロセッサ対応: カーネルがスレッドを管理するため、マルチプロセッサ環境での真の並列実行が可能です。

  - システムコールの影響: あるカーネルスレッドがシステムコールでブロックされると、他のスレッドはその影響を受けません。

- ユーザスレッド (User-level Threads)：
  - ライブラリ管理: ユーザスレッドは、OSカーネルではなく、ユーザレベルのライブラリ（例: POSIXスレッド）によって管理されます。

  - コンテキストスイッチのコスト: ユーザレベルでのコンテキストスイッチは軽量です。
                             カーネルモードとユーザモードの間での切り替えが不要なため、スイッチの速度が速いです。

  - マルチプロセッサ対応の制限: ユーザスレッドの実行は、通常、単一のプロセッサ上で行われます。
                            したがって、マルチプロセッサでの真の並列実行は困難です。

  - システムコールの影響: あるユーザスレッドがシステムコールでブロックされると、そのプロセス内のすべてのスレッドがブロックされる可能性があります。

結論：
カーネルスレッドは、マルチプロセッサのサポートやシステムコールの際の独立性などの利点がありますが、管理やコンテキストスイッチに関するコストが高くなりがちです。

ユーザスレッドは、スレッドの操作やコンテキストスイッチが非常に高速ですが、マルチプロセッサ環境やシステムコールの際に制約が生じることがあります。

実際のアプリケーションやシステムに応じて、適切なスレッドのタイプを選択することが重要です。
